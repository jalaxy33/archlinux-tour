
上篇：安装archlinux的[准备工作](https://github.com/jalaxy33/archlinux-tour/wiki/安装archlinux#准备工作)


在必要的准备工作后，这部分将手动安装 archlinux 系统本体。


## 硬盘分区

关于文件系统、EFI系统分区（ESP）、挂载点等概念请看[这篇文章](https://github.com/SHORiN-KiWATA/ShorinArchExperience-ArchlinuxGuide/wiki/安装ArchLinux#重要概念讲解)

### 创建分区


1. 查看分区情况
    ```sh
    lsblk -pf #查看分区情况
    fdisk -l /dev/想要查询详细情况的硬盘  #小写字母l，查看详细分区信息
    ```
    
    确保硬盘的分区表类型是gpt：[检查方法](https://github.com/jalaxy33/archlinux-tour/wiki/安装archlinux/检查分区表类型)


2. 用`cfdisk`创建分区

    ```sh
    cfdisk /dev/nvme0n1 #选择自己要使用的硬盘进行分区
    ```

    - 如果是新硬盘的话会弹出选项，选GPT。

    - **创建efi启动分区**：

        创建512MB的分区，类型（type）选择`efi system`。

        如果类型里没有`efi system`的话，说明不是GPT分区表，请按照[这个教程](https://github.com/jalaxy33/archlinux-tour/wiki/安装archlinux/检查分区表类型)修改。

    - **创建根分区**：

        其余空间全部分到一个分区里（直接回车），类型linux filesystem。


3. 保存分区结果

    `Write`保存 > 输入`yes`确认保存 > `Quit`退出 > ctrl+l或`clear`清屏



### 格式化分区

通过格式化为分区创建需要的文件系统。


1. 再次查看分区情况

    ```sh
    lsblk -pf #查看分区情况
    fdisk -l /dev/想要查询详细情况的硬盘  #小写字母l，查看详细分区信息
    ```

2. 格式化efi启动分区为FAT32格式：

    ```sh
    mkfs.fat -F 32 /dev/nvme0n1p1（EFI分区名）
    ```

3. 格式化根分区为btrfs格式：
    
    ```sh
    mkfs.btrfs /dev/nvme0n1p2（根分区名）
    ```
    注：加上 `-f` 参数可以强制格式化

    
### 创建btrfs子卷

本文使用btrfs文件系统，最大的特点是快照（相当于存档和回档）。**子卷**是btrfs的一个特性，跟快照有关。

通常至少要创建root子卷（存放系统文件）和home子卷（存放用户文件），根据命名规范取名为`@`和`@home`。两者是平级关系，需要分别设置快照。


1. 临时挂载根分区

    ```sh
    mount -t btrfs /dev/nvme0n1p2（根分区名） /mnt
    ```

    `mount` 挂载命令；`-t` 指定文件系统。

    > 这条命令把`/dev/nvme0n1p2`分区挂载到了`/mnt`目录，而`/dev/nvme0n1p2`是我们将要安装的系统的根分区，这意味着`/mnt`成为了我们将要安装的系统的根目录。


2. 创建子卷

    - 必须创建root和home子卷：
        ```sh
        btrfs subvolume create /mnt/@
        btrfs subvolume create /mnt/@home
        ```

    - 可选：如果需要硬盘休眠的话，创建一个swap子卷（不需要的话就跳过）

        ```sh
        btrfs subvolume create /mnt/@swap #不需要休眠到硬盘功能的话跳过这个
        ```

    - 可选：推荐再创建一个子卷，存放不需要被快照备份的数据（我的习惯是叫`Unsnap`）
        ```sh
        btrfs subvolume create /mnt/@Unsnap  #起一个名字
        ```


3. 可选：确认挂载情况
    ```sh
    btrfs subvolume list -p /mnt
    ```


4. 取消临时挂载

    ```sh
    umount /mnt
    ```


### 正式挂载

1. 挂载root子卷

    ```sh
    mount -t btrfs -o subvol=/@,compress=zstd /dev/nvme0n1p2 /mnt

    `-o` 指定额外的挂载参数；
    `compress=zstd` 指定透明压缩，zstd是压缩算法。
    ```


    和刚刚的挂载是一样的操作，不过这次是把`/dev/nvme0n1p2`上的`@`子卷挂载到了`/mnt`，而不是把`/dev/nvme0n1p2`挂载到`/mnt`。
    
    > **透明压缩**：`compress`是btrfs的另一个特性，透明压缩。可以通过算法在数据写入磁盘前先对数据进行压缩，用以节省磁盘空间，延长磁盘寿命，代价是一点点cpu占用，但极小，对现代硬件来说几乎可以忽略不计。zstd是最平衡的压缩算法，可以像这样`zstd:3`指定压缩等级，最高15，通常3就可以了。


2. 挂载home子卷

    ```sh
    mount --mkdir -t btrfs -o subvol=/@home,compress=zstd /dev/nvme0n1p2 /mnt/home
    ```

    加上`--mkdir`参数创建`/mnt/home`用来挂载


3. 可选：挂载swap子卷（不需要休眠功能的话跳过这一步）

    ```sh
    mount --mkdir -t btrfs -o subvol=/@swap,compress=zstd /dev/nvme0n1p2 /mnt/swap
    ```

4. 可选：如果创建了其他子卷，可以用同样的方式挂载，例如之前创建的`Unsnap`子卷：
    
    ```sh
    mount --mkdir -t btrfs -o subvol=/@Unsnap,compress=zstd /dev/nvme0n1p2 /mnt/Unsnap
    ```

5. 挂载efi启动分区:

    ```sh
    mount --mkdir /dev/nvme0n1p1 /mnt/efi
    ```
    记得把`/dev/nvme0n1p1`替换为自己对应的efi分区设备名。


6. 复查挂载情况：

    ```sh
    df -h
    ```


## 安装系统

### 安装系统本体

```sh
pacstrap -K /mnt base base-devel linux linux-firmware btrfs-progs

-K 复制密钥
base是基本包
base-devel是编译其他软件的时候用的
linux是主线内核，可以更换别的
linux-firmware是基本固件
btrfs-progs是btrfs文件系统的管理工具
```

`pacstrap`命令是把软件安装到指定的根目录下。



> **linux内核的选择**：要续航装`linux`，要性能装`linux-zen`。推荐多装一个 `linux-lts` 稳定版内核以备不时之需。


### 安装必要的功能性软件

- 联网工具，`networkmanager`与kde和gnome深度集成，有需求可以换成别的
    ```sh
    pacstrap /mnt networkmanager
    ```

- 任意文本编辑器，如 `vim` 或 `gvim`
    ```sh
    pacstrap /mnt vim 
    ```

- sudo权限开关
    ```sh
    pacstrap /mnt sudo 
    ```

- 内核微码，用于修复和优化cpu，根据自己的cpu安装
    ```sh
    pacstrap /mnt intel-ucode  #intel用户装这个
    pacstrap /mnt amd-ucode  #amd用户装这个
    ```

- **注意**：如果你使用的是marvell的无线网卡，这里要额外安装`linux-firmware-marvell`，否则进系统找不到网卡。



### 可选：配置swap交换空间

**如果你不需要睡眠功能的话跳过这一步**。睡眠指的是把系统当前状态写入硬盘，然后电脑完全断电，下一次开机恢复到睡眠前的状态。

swap交换空间与虚拟内存和睡眠有关。有swap分区或者swap文件两种方式，前者配置更简单，后者配置稍复杂，但是更加灵活。如果需要配置，可以参考:
- [设置swap分区](https://github.com/SHORiN-KiWATA/ShorinArchExperience-ArchlinuxGuide/wiki/安装ArchLinux#disk-configuration-磁盘分区)
- [设置swap文件](https://github.com/SHORiN-KiWATA/ShorinArchExperience-ArchlinuxGuide/wiki/安装ArchLinux#可选swap交换空间)



### 生成fstab文件系统表

系统会根据fstab中的内容自动进行挂载。
```sh
genfstab -U /mnt > /mnt/etc/fstab
```

`genfstab` 生成文件系统表；`-U` 用uuid指定分区

`>` 大于号代表输出结果覆盖写入到右边的文件里；如果是`>>`两个大于号则代表追加写入



## 系统初始配置

### 进入系统(chroot)

进入刚刚安装的系统
```sh
arch-chroot /mnt
```

此时根目录从live环境变成了`/mnt`，可以注意到提示符的变化。


### 设置时间和时区

- 设置时区为上海：

    ```sh
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
    ```
    或者：
    ```sh
    timedatectl set-timezone "Aisa/Shanghai"
    ```

- 生成调节时间误差的文件：
    
    ```sh
    hwclock --systohc
    ```


### 设置主机名

```sh
vim /etc/hostname
```
取一个名字，例如 `archlinux`，保存退出。


### 设置root密码

```sh
passwd 
```

输入过程不显示，直接输入回车即可。



### 安装GRUB引导程序


根据esp挂载点和个人需求的不同，bootloader的选择也会不同。这里安装最常用的`grub`，采用的是esp挂载点为`/efi`且grub装进esp的方案。

本文提供 UEFI 引导的安装方式，如果是 bios 设备请看 [archwiki-GRUB](https://wiki.archlinux.org/title/GRUB)。

1. 安装必要的软件包

```sh
pacman -S grub efibootmgr os-prober exfat-utils
```

`efibootmgr` 管理uefi启动项；

`os-prober`和`exfat-utils` 用来搜索win11（不配置双系统的话可以不装）。


2. 安装grub

```sh
grub-install --target=x86_64-efi --efi-directory=/efi --boot-directory=/efi --bootloader-id=ARCH 
```

- `grub-install`安装grub；
 
- `--target` 指定架构；
 
- `--efi-directory` 指定efi文件的目录（esp）；
 
- `--boot-directory` 指定grub文件的目录；
 
- `--bootloader-id` 任意取一个启动项名字；
 
- PS：如果是移动设备或者主板只支持默认的efi路径要加上`--removable`选项。


3. GRUB的后续配置请查看：[重启前的工作](https://github.com/jalaxy33/archlinux-tour/wiki/安装后重启前的工作)



### 退出chroot

```sh
exit
```
此时就回到了live环境，可以注意到提示符的变化。




## 下一步：[重启前的工作](https://github.com/jalaxy33/archlinux-tour/wiki/安装后重启前的工作)

